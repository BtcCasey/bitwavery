<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>16-BIT BTC SINGULARITY</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #010208; font-family: 'Press Start 2P', cursive; color: #fff; }
        #ui {
            position: absolute; top: 25px; left: 25px; z-index: 100;
            background: rgba(0,0,0,0.9); padding: 18px; border: 2px solid #5e43f3;
            box-shadow: 0 0 20px rgba(94, 67, 243, 0.4);
        }
        .label { font-size: 8px; color: #5e43f3; margin-bottom: 8px; letter-spacing: 1px; }
        #price { font-size: 16px; color: #fff; margin: 0; }
        #status { font-size: 7px; margin-top: 10px; color: #00ffcc; }
        canvas { display: block; image-rendering: pixelated; width: 100vw; height: 100vh; }
    </style>
</head>
<body>

<div id="ui">
    <div class="label">CORE SIGNAL: BITCOIN</div>
    <h1 id="price">INITIALIZING...</h1>
    <div id="status">SCANNING DEEP SPACE...</div>
</div>

<canvas id="screen"></canvas>

<script>
    const canvas = document.getElementById('screen');
    const ctx = canvas.getContext('2d');
    const priceDisplay = document.getElementById('price');
    const statusDisplay = document.getElementById('status');

    const RES_W = 480; const RES_H = 270;
    canvas.width = RES_W; canvas.height = RES_H;

    let targetPrice = 0, currentPrice = 0, volatility = 0;
    let lastUpdate = Date.now();
    let particles = [];
    
    // Background Starfield
    let bgStars = Array.from({length: 120}, () => ({
        x: Math.random() * RES_W, y: Math.random() * RES_H,
        s: Math.random() * 1.5, v: 0.1 + Math.random() * 0.4
    }));

    // Orbital Particles
    for(let i=0; i < 150; i++) {
        particles.push({
            a: Math.random() * Math.PI * 2,
            d: 50 + Math.random() * 30,
            v: 0.01 + Math.random() * 0.03,
            sz: 1 + Math.random() * 2,
            c: "#00ffcc"
        });
    }

    // --- NEW MULTI-CHANNEL DATA STREAM ---
    function initDataStream() {
        // Source 1: CoinCap WebSocket (Highly reliable)
        const ws = new WebSocket('wss://ws.coincap.io/prices?assets=bitcoin');
        
        ws.onmessage = (e) => {
            const data = JSON.parse(e.data);
            if (data.bitcoin) processUpdate(parseFloat(data.bitcoin), "LIVE STREAM");
        };

        ws.onerror = () => { ws.close(); startFallback(); };
        ws.onclose = () => startFallback();

        // Safety Trigger: If no data for 3 seconds, force fallback
        setTimeout(() => { if(targetPrice === 0) startFallback(); }, 3000);
    }

    async function startFallback() {
        statusDisplay.innerText = "● FALLBACK MODE: REST";
        statusDisplay.style.color = "#f7931a";
        setInterval(async () => {
            try {
                const res = await fetch('https://api.coincap.io/v2/assets/bitcoin');
                const data = await res.json();
                processUpdate(parseFloat(data.data.priceUsd), "REST SYNC");
            } catch(e) { statusDisplay.innerText = "● SIGNAL LOST"; }
        }, 1000);
    }

    function processUpdate(price, mode) {
        volatility = targetPrice === 0 ? 0 : Math.abs(price - targetPrice);
        targetPrice = price;
        lastUpdate = Date.now();
        priceDisplay.innerText = `$${Math.floor(targetPrice).toLocaleString()}`;
        if(mode !== "REST SYNC") statusDisplay.innerText = "● SIGNAL STABLE";
    }

    function render(time) {
        ctx.fillStyle = "#010208";
        ctx.fillRect(0, 0, RES_W, RES_H);

        // Stars
        ctx.fillStyle = "#fff";
        bgStars.forEach(s => {
            s.x = (s.x - s.v + RES_W) % RES_W;
            ctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.s, s.s);
        });

        if (targetPrice === 0) { requestAnimationFrame(render); return; }

        currentPrice += (targetPrice - currentPrice) * 0.05;
        const centerX = RES_W / 2;
        const centerY = RES_H / 2;

        // Core Pulsar
        const pulse = Math.sin(time / 150) * (5 + volatility);
        const coreSize = 30 + pulse;
        
        // Glow
        const g = ctx.createRadialGradient(centerX, centerY, 2, centerX, centerY, coreSize * 1.5);
        g.addColorStop(0, "#fff");
        g.addColorStop(0.2, "#5e43f3");
        g.addColorStop(1, "transparent");
        ctx.fillStyle = g;
        ctx.fillRect(centerX - 100, centerY - 100, 200, 200);

        // Orbitals
        particles.forEach(p => {
            p.a += p.v * (1 + (volatility * 0.2));
            // Expansion based on price modulo
            const drift = (currentPrice % 100) / 2;
            const x = centerX + Math.cos(p.a) * (p.d + drift);
            const y = centerY + Math.sin(p.a) * (p.d + drift);
            
            ctx.fillStyle = volatility > 5 ? "#ff4466" : "#00ffcc";
            ctx.fillRect(Math.floor(x), Math.floor(y), p.sz, p.sz);
        });

        // HUD Geometry
        ctx.strokeStyle = "rgba(94, 67, 243, 0.2)";
        ctx.beginPath();
        ctx.arc(centerX, centerY, 100, 0, Math.PI * 2);
        ctx.moveTo(centerX - 120, centerY); ctx.lineTo(centerX + 120, centerY);
        ctx.stroke();

        requestAnimationFrame(render);
    }

    initDataStream();
    requestAnimationFrame(render);
</script>
</body>
</html>
