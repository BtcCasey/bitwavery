<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>16-BIT BTC EVENT HORIZON</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #010208; font-family: 'Press Start 2P', cursive; color: #fff; }
        #ui {
            position: absolute; top: 25px; left: 25px; z-index: 100;
            background: rgba(0,0,0,0.9); padding: 18px; border: 2px solid #5e43f3;
        }
        .label { font-size: 8px; color: #5e43f3; margin-bottom: 8px; }
        #price { font-size: 16px; color: #fff; margin: 0; }
        #event-log { position: absolute; bottom: 20px; left: 20px; font-size: 8px; color: #00ffcc; line-height: 1.5; }
        canvas { display: block; image-rendering: pixelated; width: 100vw; height: 100vh; }
    </style>
</head>
<body>

<div id="ui">
    <div class="label">BITCOIN MAIN SEQUENCE</div>
    <h1 id="price">SYNCING...</h1>
</div>

<div id="event-log"></div>
<canvas id="screen"></canvas>

<script>
    const canvas = document.getElementById('screen');
    const ctx = canvas.getContext('2d');
    const priceDisplay = document.getElementById('price');
    const logDisplay = document.getElementById('event-log');

    const RES_W = 480; const RES_H = 270;
    canvas.width = RES_W; canvas.height = RES_H;

    let targetPrice = 0, lastBarrier100 = 0, lastBarrier500 = 0, lastBarrier1000 = 0;
    let effects = []; // Stores active animations (ships, UFOs, pulsar waves)

    function logEvent(msg) {
        const div = document.createElement('div');
        div.innerText = `> ${msg}`;
        logDisplay.prepend(div);
        if(logDisplay.children.length > 5) logDisplay.lastChild.remove();
    }

    // --- EFFECT CLASSES ---
    class PulsarWave {
        constructor(x, y) { this.x = x; this.y = y; this.r = 0; this.life = 1.0; }
        update() { this.r += 4; this.life -= 0.02; }
        draw() {
            ctx.strokeStyle = `rgba(255, 255, 255, ${this.life})`;
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke();
        }
    }

    class Spaceship {
        constructor() { this.x = -50; this.y = Math.random()*RES_H; this.vx = 3; }
        update() { this.x += this.vx; }
        draw() {
            ctx.fillStyle = "#aaa"; ctx.fillRect(this.x, this.y, 15, 5); // Hull
            ctx.fillStyle = "#00f"; ctx.fillRect(this.x+10, this.y+1, 3, 3); // Cockpit
        }
    }

    class UFO {
        constructor() { this.x = RES_W+50; this.y = Math.random()*RES_H; this.vx = -2; this.osc = 0; }
        update() { this.x += this.vx; this.osc += 0.1; }
        draw() {
            const dy = Math.sin(this.osc) * 10;
            ctx.fillStyle = "#0f0"; ctx.fillRect(this.x, this.y+dy, 20, 4); // Disc
            ctx.fillStyle = "#fff"; ctx.fillRect(this.x+7, this.y-3+dy, 6, 4); // Dome
        }
    }

    class BlackHole {
        constructor() { this.life = 120; this.r = 0; }
        update() { this.life--; this.r = Math.min(60, this.r + 2); }
        draw() {
            ctx.fillStyle = `rgba(0,0,0,${this.life/120})`;
            ctx.beginPath(); ctx.arc(RES_W/2, RES_H/2, this.r, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "#ff00ff"; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(RES_W/2, RES_H/2, this.r + Math.sin(this.life/5)*5, 0, Math.PI*2); ctx.stroke();
        }
    }

    // --- DATA HANDLING ---
    function connect() {
        const ws = new WebSocket('wss://api-pub.bitfinex.com/ws/2');
        ws.onopen = () => {
            ws.send(JSON.stringify({ event: 'subscribe', channel: 'ticker', symbol: 'tBTCUSD' }));
            ws.send(JSON.stringify({ event: 'subscribe', channel: 'trades', symbol: 'tBTCUSD' }));
        };

        ws.onmessage = (msg) => {
            const data = JSON.parse(msg.data);
            if (!Array.isArray(data)) return;

            // Handle Ticker (Price)
            if (data[1] && Array.isArray(data[1]) && data[1].length > 6) {
                const price = data[1][6];
                checkBarriers(price);
                targetPrice = price;
                priceDisplay.innerText = `$${Math.floor(price).toLocaleString()}`;
            }

            // Handle Trades (Volume)
            if (data[1] === "te") {
                const amount = Math.abs(data[2][2]);
                const price = data[2][3];
                const usdValue = amount * price;
                if (usdValue >= 10000) {
                    effects.push(new BlackHole());
                    logEvent(`VOID DETECTED: $${Math.floor(usdValue).toLocaleString()} TRADE`);
                }
            }
        };
    }

    function checkBarriers(p) {
        if (targetPrice === 0) return;
        
        // $100 Pulsar
        if (Math.floor(p/100) !== Math.floor(targetPrice/100)) {
            effects.push(new PulsarWave(RES_W/2, RES_H/2));
            logEvent("PULSAR: $100 BARRIER CROSS");
        }
        // $500 Spaceship
        if (Math.floor(p/500) !== Math.floor(targetPrice/500)) {
            effects.push(new Spaceship());
            logEvent("NAVIGATOR ENTERING SECTOR");
        }
        // $1000 UFO
        if (Math.floor(p/1000) !== Math.floor(targetPrice/1000)) {
            effects.push(new UFO());
            logEvent("UNKNOWN SIGNAL DETECTED");
        }
    }

    function render() {
        ctx.fillStyle = "#010208"; ctx.fillRect(0, 0, RES_W, RES_H);
        
        // Draw the Core
        const g = ctx.createRadialGradient(RES_W/2, RES_H/2, 5, RES_W/2, RES_H/2, 40);
        g.addColorStop(0, "#fff"); g.addColorStop(0.5, "#5e43f3"); g.addColorStop(1, "transparent");
        ctx.fillStyle = g; ctx.fillRect(RES_W/2-50, RES_H/2-50, 100, 100);

        // Update and Draw Effects
        effects = effects.filter(e => {
            e.update(); e.draw();
            return (e.life === undefined || e.life > 0) && (e.x === undefined || (e.x > -100 && e.x < RES_W+100));
        });

        requestAnimationFrame(render);
    }

    connect(); render();
</script>
</body>
</html>
