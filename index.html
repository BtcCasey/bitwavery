<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-Bit BTC Chart Navigator</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; overflow: hidden; background: #000; 
            font-family: 'Press Start 2P', cursive; color: #fff;
            image-rendering: pixelated;
        }
        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: #000; padding: 15px; border: 4px solid #fff;
            box-shadow: 4px 4px 0px #f7931a;
        }
        .label { font-size: 8px; color: #aaa; margin-bottom: 8px; }
        #price { font-size: 16px; color: #f7931a; margin: 0; }
        canvas { width: 100vw; height: 100vh; display: block; }
    </style>
</head>
<body>

<div id="ui">
    <div class="label">LIVE MARKET DEPTH</div>
    <h1 id="price">SYNCING...</h1>
</div>

<canvas id="screen"></canvas>

<script>
    const canvas = document.getElementById('screen');
    const ctx = canvas.getContext('2d');
    const priceDisplay = document.getElementById('price');

    // 8-bit Resolution
    const RES_W = 256;
    const RES_H = 240;
    canvas.width = RES_W;
    canvas.height = RES_H;

    let btcPrice = 0;
    let priceHistory = new Array(64).fill(0); // Holds the "wave" data
    let minPrice = Infinity;
    let maxPrice = -Infinity;

    // 1. Fetch Price & Push to History
    async function updatePrice() {
        try {
            const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
            const data = await res.json();
            const current = data.bitcoin.usd;
            
            btcPrice = current;
            priceDisplay.innerText = `$${Math.floor(current).toLocaleString()}`;
            
            // Push new price and shift history
            priceHistory.push(current);
            priceHistory.shift();

            // Calculate min/max for scaling the "Ocean"
            const activePrices = priceHistory.filter(p => p > 0);
            minPrice = Math.min(...activePrices) * 0.999; // Slight padding
            maxPrice = Math.max(...activePrices) * 1.001;
        } catch (e) { console.log("API Error"); }
    }

    // Update more frequently for "smooth" charting
    setInterval(updatePrice, 5000);
    updatePrice();

    function drawPixelShip(x, y) {
        ctx.fillStyle = "#f7931a";
        ctx.fillRect(x - 6, y, 12, 4); // Hull
        ctx.fillStyle = "#fff";
        ctx.fillRect(x - 1, y - 8, 2, 8); // Mast
        ctx.fillRect(x + 1, y - 7, 4, 4); // Sail
    }

    function render() {
        // Clear sky
        ctx.fillStyle = "#081426";
        ctx.fillRect(0, 0, RES_W, RES_H);

        // Draw Moon (based on ATH proximity)
        ctx.fillStyle = "#fff";
        ctx.fillRect(RES_W - 40, 30, 16, 16);

        // Draw the Price Wave
        const step = RES_W / (priceHistory.length - 1);
        ctx.fillStyle = "#2d4d86";
        
        let shipY = RES_H / 2;

        for (let i = 0; i < priceHistory.length; i++) {
            const x = i * step;
            let y = RES_H / 2;

            if (priceHistory[i] > 0) {
                // Map the price to the screen height
                const normalized = (priceHistory[i] - minPrice) / (maxPrice - minPrice);
                y = (RES_H * 0.8) - (normalized * 100);
            }

            // The ship sits on the VERY LAST price point (the leading edge)
            if (i === priceHistory.length - 1) {
                shipY = y;
            }

            // Draw blocky column
            ctx.fillRect(Math.floor(x), Math.floor(y), Math.ceil(step), RES_H - y);
        }

        // Add a "water line" highlight
        ctx.fillStyle = "#5d85c4";
        for (let i = 0; i < priceHistory.length; i++) {
            const x = i * step;
            const normalized = (priceHistory[i] - minPrice) / (maxPrice - minPrice);
            const y = (RES_H * 0.8) - (normalized * 100);
            ctx.fillRect(Math.floor(x), Math.floor(y), Math.ceil(step), 2);
        }

        drawPixelShip(RES_W - 10, shipY - 4);

        requestAnimationFrame(render);
    }

    render();
</script>
</body>
</html>
