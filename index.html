<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>16-BIT BTC SINGULARITY (STABLE)</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #010208; font-family: 'Press Start 2P', cursive; color: #fff; }
        #ui {
            position: absolute; top: 25px; left: 25px; z-index: 100;
            background: rgba(0,0,0,0.95); padding: 18px; border: 2px solid #5e43f3;
            box-shadow: 0 0 20px rgba(94, 67, 243, 0.6);
        }
        .label { font-size: 8px; color: #5e43f3; margin-bottom: 8px; letter-spacing: 1px; }
        #price { font-size: 16px; color: #fff; margin: 0; }
        #status { font-size: 7px; margin-top: 10px; color: #00ffcc; text-transform: uppercase; }
        canvas { display: block; image-rendering: pixelated; width: 100vw; height: 100vh; }
    </style>
</head>
<body>

<div id="ui">
    <div class="label">CORE SIGNAL: BITCOIN</div>
    <h1 id="price">SYNCING...</h1>
    <div id="status">INITIATING DEEP SCAN...</div>
</div>

<canvas id="screen"></canvas>

<script>
    const canvas = document.getElementById('screen');
    const ctx = canvas.getContext('2d');
    const priceDisplay = document.getElementById('price');
    const statusDisplay = document.getElementById('status');

    const RES_W = 480; const RES_H = 270;
    canvas.width = RES_W; canvas.height = RES_H;

    let targetPrice = 0, currentPrice = 0, volatility = 0;
    let particles = [];
    let lastHeartbeat = Date.now();
    
    // Starfield Generation
    let bgStars = Array.from({length: 100}, () => ({
        x: Math.random() * RES_W, y: Math.random() * RES_H,
        s: Math.random() * 1.5, v: 0.05 + Math.random() * 0.2
    }));

    for(let i=0; i < 120; i++) {
        particles.push({ a: Math.random() * Math.PI * 2, d: 50 + Math.random() * 40, v: 0.01 + Math.random() * 0.02, sz: 1 + Math.random() * 1.5 });
    }

    // --- TRIPLE REDUNDANCY ENGINE ---
    function connect() {
        statusDisplay.innerText = "ATTEMPTING WS LINK...";
        // Bitfinex is generally more "open" than Binance or CoinCap
        const ws = new WebSocket('wss://api-pub.bitfinex.com/ws/2');
        
        ws.onopen = () => {
            ws.send(JSON.stringify({ event: 'subscribe', channel: 'ticker', symbol: 'tBTCUSD' }));
        };

        ws.onmessage = (msg) => {
            const data = JSON.parse(msg.data);
            if (Array.isArray(data[1])) {
                const btc = data[1][6]; // Last price index for Bitfinex
                updateData(btc, "LIVE STREAM");
            }
        };

        ws.onclose = ws.onerror = () => {
            statusDisplay.innerText = "WS BLOCKED - STARTING REST";
            startPolling();
        };
    }

    async function startPolling() {
        const fetchPrice = async () => {
            try {
                // Using CoinGecko as the heavy-duty backup
                const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
                const data = await res.json();
                updateData(data.bitcoin.usd, "REST POLLING");
            } catch (e) {
                statusDisplay.innerText = "SIGNAL WEAK - DRIFT MODE";
            }
        };
        fetchPrice();
        setInterval(fetchPrice, 5000); // 5s fallback polling
    }

    function updateData(p, mode) {
        volatility = targetPrice === 0 ? 0 : Math.abs(p - targetPrice);
        targetPrice = p;
        lastHeartbeat = Date.now();
        priceDisplay.innerText = `$${Math.floor(targetPrice).toLocaleString()}`;
        statusDisplay.innerText = `â— SIGNAL: ${mode}`;
        statusDisplay.style.color = mode.includes("STREAM") ? "#00ffcc" : "#f7931a";
    }

    function render(time) {
        ctx.fillStyle = "#010208";
        ctx.fillRect(0, 0, RES_W, RES_H);

        // Background Stars
        ctx.fillStyle = "#fff";
        bgStars.forEach(s => {
            s.x = (s.x - s.v + RES_W) % RES_W;
            ctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.s, s.s);
        });

        // "Ghosting" logic - if no price yet, don't crash, just wait
        if (targetPrice === 0) {
            ctx.fillStyle = "rgba(94, 67, 243, 0.2)";
            ctx.fillText("WAITING FOR CORE...", RES_W/2 - 60, RES_H/2);
            requestAnimationFrame(render);
            return;
        }

        currentPrice += (targetPrice - currentPrice) * 0.05;
        const centerX = RES_W / 2;
        const centerY = RES_H / 2;

        // Pulsar Core
        const pulse = Math.sin(time / 200) * (3 + (volatility * 0.5));
        const coreSize = 25 + pulse;
        
        const grad = ctx.createRadialGradient(centerX, centerY, 2, centerX, centerY, coreSize * 2);
        grad.addColorStop(0, "#fff");
        grad.addColorStop(0.3, "#5e43f3");
        grad.addColorStop(1, "transparent");
        ctx.fillStyle = grad;
        ctx.fillRect(centerX-80, centerY-80, 160, 160);

        // Orbital Belt
        particles.forEach(p => {
            p.a += p.v * (1 + (volatility * 0.1));
            const drift = (currentPrice % 80) / 2;
            const x = centerX + Math.cos(p.a) * (p.d + drift);
            const y = centerY + Math.sin(p.a) * (p.d + drift);
            ctx.fillStyle = volatility > 2 ? "#ff4d6d" : "#00ffcc";
            ctx.fillRect(Math.floor(x), Math.floor(y), p.sz, p.sz);
        });

        // Scanline Effect (For that 16-bit CRT feel)
        if (Math.floor(time/50) % 2 === 0) {
            ctx.fillStyle = "rgba(255,255,255,0.02)";
            for(let i=0; i<RES_H; i+=2) ctx.fillRect(0, i, RES_W, 1);
        }

        requestAnimationFrame(render);
    }

    connect();
    requestAnimationFrame(render);
</script>
</body>
</html>
