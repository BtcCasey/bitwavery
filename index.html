<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC SINGULARITY - STABLE v2</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #010208; font-family: 'Press Start 2P', cursive; color: #fff; transition: background 1.5s; }
        #ui { position: absolute; top: 25px; left: 25px; z-index: 100; background: rgba(0,0,0,0.9); padding: 18px; border: 2px solid #5e43f3; box-shadow: 0 0 20px rgba(94, 67, 243, 0.4); }
        #price { font-size: 18px; color: #fff; margin: 0; text-shadow: 2px 2px #000; }
        #event-log { position: absolute; bottom: 40px; left: 20px; font-size: 7px; color: #00ffcc; line-height: 1.6; pointer-events: none; text-transform: uppercase; }
        #status-hud { position: absolute; bottom: 15px; left: 20px; font-size: 6px; color: #555; }
        canvas { display: block; image-rendering: pixelated; width: 100vw; height: 100vh; }
    </style>
</head>
<body>

<div id="ui">
    <div style="font-size: 8px; color: #5e43f3; margin-bottom: 8px;">SIGNAL: BITCOIN MAINNET</div>
    <h1 id="price">INITIALIZING...</h1>
</div>

<div id="event-log"></div>
<div id="status-hud">CONNECTION: STANDBY...</div>
<canvas id="screen"></canvas>

<script>
    const canvas = document.getElementById('screen');
    const ctx = canvas.getContext('2d');
    const priceDisplay = document.getElementById('price');
    const logDisplay = document.getElementById('event-log');
    const hud = document.getElementById('status-hud');

    const RES_W = 480; const RES_H = 270;
    canvas.width = RES_W; canvas.height = RES_H;

    let targetPrice = 0, currentPrice = 0, priceDirection = 0;
    let supernovaAlpha = 0;
    let effects = [];
    let trail = [];
    let bgStars = Array.from({length: 80}, () => ({ x: Math.random()*RES_W, y: Math.random()*RES_H, s: Math.random()*1.5, v: 0.1 + Math.random()*0.3 }));

    function logEvent(msg) {
        const div = document.createElement('div'); div.innerText = `> ${msg}`;
        logDisplay.prepend(div); if(logDisplay.children.length > 5) logDisplay.lastChild.remove();
    }

    // --- EFFECTS ---
    class PulsarWave { constructor() { this.r = 10; this.life = 1.0; } update() { this.r += 3.5; this.life -= 0.02; } draw() { ctx.strokeStyle = `rgba(255,255,255,${this.life})`; ctx.beginPath(); ctx.arc(RES_W/2, RES_H/2, this.r, 0, Math.PI*2); ctx.stroke(); } }
    class Spaceship { constructor() { this.x = -50; this.y = RES_H/2 + (Math.random()*80-40); this.v = 2.8; } update() { this.x += this.v; } draw() { ctx.fillStyle = "#aaa"; ctx.fillRect(this.x, this.y, 14, 4); ctx.fillStyle = "#0cf"; ctx.fillRect(this.x+10, this.y+1, 3, 2); } }
    class UFO { constructor() { this.x = RES_W+50; this.y = 70; this.v = -1.5; this.t = 0; } update() { this.x += this.v; this.t += 0.08; } draw() { const dy = Math.sin(this.t)*20; ctx.fillStyle = "#0f0"; ctx.fillRect(this.x, this.y+dy, 18, 5); ctx.fillStyle = "#fff"; ctx.fillRect(this.x+6, this.y-3+dy, 6, 3); } }
    class BlackHole { constructor() { this.r = 0; this.life = 120; } update() { this.r = Math.min(60, this.r + 4); this.life--; } draw() { ctx.fillStyle = `rgba(0,0,0,${this.life/120})`; ctx.beginPath(); ctx.arc(RES_W/2, RES_H/2, this.r, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = "#ff00ff"; ctx.stroke(); } }

    // --- DUAL-MODE DATA ENGINE ---
    async function init() {
        hud.innerText = "CONNECTION: ATTEMPTING LIVE STREAM...";
        const ws = new WebSocket('wss://api-pub.bitfinex.com/ws/2');
        let wsActive = false;

        const failSafeTimeout = setTimeout(() => {
            if (!wsActive) {
                hud.innerText = "CONNECTION: WS BLOCKED. ACTIVATING FAIL-SAFE REST...";
                startRestPolling();
            }
        }, 3000);

        ws.onopen = () => {
            wsActive = true;
            clearTimeout(failSafeTimeout);
            hud.innerText = "CONNECTION: LIVE STREAM ENCRYPTED";
            ws.send(JSON.stringify({ event: 'subscribe', channel: 'ticker', symbol: 'tBTCUSD' }));
            ws.send(JSON.stringify({ event: 'subscribe', channel: 'trades', symbol: 'tBTCUSD' }));
        };

        ws.onmessage = (msg) => {
            const data = JSON.parse(msg.data);
            if (!Array.isArray(data)) return;
            if (data[1] && Array.isArray(data[1]) && data[1].length > 6) {
                updatePrice(data[1][6]);
            }
            if (data[1] === "te") {
                const usdValue = Math.abs(data[2][2] * data[2][3]);
                if (usdValue >= 10000) { effects.push(new BlackHole()); logEvent("WHALE TRADE DETECTED"); }
            }
        };

        ws.onerror = () => { if(!wsActive) startRestPolling(); };
    }

    async function startRestPolling() {
        const fetchPrice = async () => {
            try {
                const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
                const data = await res.json();
                updatePrice(data.bitcoin.usd);
            } catch (e) { hud.innerText = "CONNECTION: ALL SIGNALS LOST."; }
        };
        fetchPrice();
        setInterval(fetchPrice, 10000); // Poll every 10s for stability
    }

    function updatePrice(newPrice) {
        if (targetPrice > 0) {
            priceDirection = newPrice >= targetPrice ? 1 : -1;
            if (Math.floor(newPrice/100) !== Math.floor(targetPrice/100)) effects.push(new PulsarWave());
            if (Math.floor(newPrice/500) !== Math.floor(targetPrice/500)) effects.push(new Spaceship());
            if (Math.floor(newPrice/1000) !== Math.floor(targetPrice/1000)) effects.push(new UFO());
        }
        targetPrice = newPrice;
        priceDisplay.innerText = `$${Math.floor(targetPrice).toLocaleString()}`;
    }

    function render(time) {
        let baseBG = priceDirection === 1 ? "#021205" : (priceDirection === -1 ? "#120202" : "#010208");
        ctx.fillStyle = baseBG; ctx.fillRect(0, 0, RES_W, RES_H);

        bgStars.forEach(s => {
            s.x = (s.x - s.v + RES_W) % RES_W;
            ctx.fillStyle = priceDirection === 1 ? "#00ff88" : (priceDirection === -1 ? "#ff4444" : "#ffffff");
            ctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.s, s.s);
        });

        if (targetPrice > 0) {
            currentPrice += (targetPrice - currentPrice) * 0.05;
            trail.push({x: RES_W/2, y: RES_H/2 + (Math.sin(time/400)*15)});
            if (trail.length > 30) trail.shift();
            trail.forEach((p, i) => {
                ctx.strokeStyle = priceDirection === 1 ? `rgba(0, 255, 136, ${i/30})` : `rgba(255, 68, 68, ${i/30})`;
                ctx.beginPath(); ctx.arc(p.x - (30 - i)*3, p.y, i/3.5, 0, Math.PI*2); ctx.stroke();
            });

            const pulse = 25 + Math.sin(time/200)*6;
            const g = ctx.createRadialGradient(RES_W/2, RES_H/2, 2, RES_W/2, RES_H/2, pulse*1.8);
            g.addColorStop(0, "#fff");
            g.addColorStop(0.4, priceDirection === 1 ? "#00ff88" : (priceDirection === -1 ? "#ff4444" : "#5e43f3"));
            g.addColorStop(1, "transparent");
            ctx.fillStyle = g; ctx.fillRect(RES_W/2-70, RES_H/2-70, 140, 140);
        } else {
            ctx.fillStyle = "#5e43f3"; ctx.fillText("SCANNING DEEP SPACE...", RES_W/2-80, RES_H/2);
        }

        effects = effects.filter(e => { e.update(); e.draw(); return (e.life === undefined || e.life > 0) && (e.x === undefined || (e.x > -60 && e.x < RES_W+60)); });
        requestAnimationFrame(render);
    }

    init(); render();
</script>
</body>
</html>
